<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>基础语法</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/mdbook-admonish.css">
        <link rel="stylesheet" href="../theme/pagetoc.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="setup.html">Setup</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Foundations of Rust</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="foundations/first-project.html"><strong aria-hidden="true">1.1.</strong> 第一个项目</a></li><li class="chapter-item "><a href="foundations/basic-syntax.html"><strong aria-hidden="true">1.2.</strong> 基础语法</a></li><li class="chapter-item "><a href="foundations/ownership-and-references.html"><strong aria-hidden="true">1.3.</strong> 所有权与引用</a></li><li class="chapter-item "><a href="foundations/advanced-syntax.html"><strong aria-hidden="true">1.4.</strong> 进阶语法</a></li><li class="chapter-item "><a href="foundations/traits-and-generics.html"><strong aria-hidden="true">1.5.</strong> 特征与泛型</a></li><li class="chapter-item "><a href="foundations/closures-and-dynamic-dispatch.html"><strong aria-hidden="true">1.6.</strong> 闭包与动态分发</a></li><li class="chapter-item "><a href="foundations/interior-mutability.html"><strong aria-hidden="true">1.7.</strong> 内部可变性</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Crate Engineering</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crate-engineering.html"><strong aria-hidden="true">2.1.</strong> Crate</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Multitasking</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="introduction-to-multitasking.html"><strong aria-hidden="true">3.1.</strong> 多任务处理简介</a></li><li class="chapter-item "><a href="parallel-multitasking.html"><strong aria-hidden="true">3.2.</strong> 并行多任务处理</a></li><li class="chapter-item "><a href="asynchronous-multitasking.html"><strong aria-hidden="true">3.3.</strong> 异步多任务处理</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <h1 id="rust-基础语法"><a class="header" href="#rust-基础语法">Rust 基础语法</a></h1>
<h2 id="变量"><a class="header" href="#变量">变量</a></h2>
<h3 id="不可变变量"><a class="header" href="#不可变变量">不可变变量</a></h3>
<p>在 Rust 中，默认情况下，变量是不可变的。
也就是说，一旦变量被赋值，就无法更改其值。这种设计有助于提高程序的安全性和可维护性，防止意外的值修改。
不可变变量的特性使得代码更具可预测性，因为程序员可以确保这些变量的值在整个作用域中不会发生改变。
这样，当你在调试代码时，可以更容易地追踪变量的值，避免因为意外修改变量而导致的 Bug。</p>
<p>下面的代码示例展示了这一点：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_x = 5;
    println!("some_x = {}", some_x);
    some_x = 6; // 尝试修改变量
    println!("some_x = {}", some_x);
}</code></pre></pre>
<p>运行该代码时会报错，因为 <code>some_x</code> 是不可变的，无法在赋值后再次更改其值。</p>
<pre><code class="language-bash">error[E0384]: cannot assign twice to immutable variable `some_x`
 --&gt; src/main.rs:4:5
  |
2 |     let some_x = 5;
  |         ------ first assignment to `some_x`
3 |     println!("some_x = {}", some_x);
4 |     some_x = 6;
  |     ^^^^^^^^^^ cannot assign twice to immutable variable
  |
help: consider making this binding mutable
  |
2 |     let mut some_x = 5;
  |         +++

For more information about this error, try `rustc --explain E0384`.
error: could not compile `test-life` (bin "test-life") due to 1 previous error
</code></pre>
<p>为了使变量可变，需要使用 <code>mut</code> 关键字。</p>
<h3 id="可变变量"><a class="header" href="#可变变量">可变变量</a></h3>
<p>使用 <code>mut</code> 关键字声明变量意味着该变量可以在其作用域内被多次修改。
这样的设计非常有用，尤其是在需要通过迭代或临时存储来改变变量状态的情况下。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut some_x = 5;  // 使用 mut 声明可变变量
    println!("some_x = {}", some_x);
    some_x = 6;  // 修改变量的值
    println!("some_x = {}", some_x);
}</code></pre></pre>
<p>使用 <code>mut</code> 声明的变量可以在初始化后修改其值。这样，程序可以成功运行，并输出：</p>
<pre><code class="language-bash">some_x = 5
some_x = 6
</code></pre>
<p>需要注意的是，虽然可变变量为我们提供了灵活性，但使用它们时需要谨慎。
因为一旦变量是可变的，就可能存在被意外修改的风险，这会增加调试的难度。
因此，在编写代码时应尽可能避免不必要的可变性。</p>
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<p>在 Rust 中，除了变量之外，还有常量。常量在程序运行期间是不可变的，并且必须在声明时指定其类型。
常量使用 <code>const</code> 关键字来声明，通常用于那些在整个程序生命周期内不会改变的值。</p>
<p>常量与不可变变量的主要区别在于，常量可以在任何作用于中声明，包括全局作用域，而且其值必须在编译时就确定下来。
常量的值不能依赖于运行时的计算，而是固定不变的，这意味着常量通常被用于定义程序中不可改变的重要数据，例如数学常数、配置参数等。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_POINTS: u32 = 100_000;
<span class="boring">}</span></code></pre></pre>
<p>常量的命名通常使用全大写字母，单词之间用下划线分隔。与变量不同，常量在声明后不会被销毁，它们在程序的整个生命周期内始终有效。</p>
<h2 id="变量遮蔽"><a class="header" href="#变量遮蔽">变量遮蔽</a></h2>
<p>在 Rust 中，可以声明一个与之前同名的新变量，这个过程称为“变量遮蔽 (shadowing)”。遮蔽允许你复用变量名而不必使用 <code>mut</code> 关键字。例如：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let x = x + 1;  // 通过遮蔽重新绑定变量 x
    let x = x * 2;

    println!("The value of x is: {}", x);  // 输出 "The value of x is: 12"
}</code></pre></pre>
<p>在这个例子中，变量 <code>x</code> 被多次声明，每次都会遮蔽前一次的值。这与使用 mut 修改变量不同，因为每次遮蔽都会创建一个新的变量，可以改变类型或不可变性。例如：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let spaces = "   "; // `spaces` 是字符串类型
    let spaces = spaces.len(); // `spaces` 被遮蔽为一个整数类型
    println!("Number of spaces: {}", spaces); // 输出 "Number of spaces: 3"
}</code></pre></pre>
<p>通过变量遮蔽，你可以使用同样的变量名绑定不同类型的值，进而提高代码的灵活性和可读性。</p>
<h2 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h2>
<p>Rust 是静态强类型语言，这意味着在编译时必须知道每个变量的类型。大多数情况数据类型可以由编译器自动推断，但在编译器无法推断类型时需要显式指定数据类型。</p>
<h3 id="整数类型"><a class="header" href="#整数类型">整数类型</a></h3>
<p>整数类型包括有符号和无符号两种类型，长度可为 8 位、16 位、32 位、64 位、128 位或基于指针大小的 <code>isize</code> 和 <code>usize</code>。无符号整数（<code>u</code> 开头）只能存储非负值，而有符号整数（<code>i</code> 开头）可以存储正负值。</p>
<div class="table-wrapper"><table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8 bits</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 bits</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 bits</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 bits</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128 bits</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>pointer-sized</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32 = 42; // i32 是最常用的整数类型
let y: u64 = 42; // 无符号 64 位整数
let z = 1_000; // 可以使用下划线分隔提高可读性
let a = 42; // 默认 i32 类型
let b = 42u64; // 指定为 u64 类型
let c = 42_000; // 使用下划线分隔
<span class="boring">}</span></code></pre></pre>
<h3 id="浮点类型"><a class="header" href="#浮点类型">浮点类型</a></h3>
<p>浮点类型用于存储带小数的数字，包括 f32（单精度）和 f64（双精度），通常默认使用 f64，因为它比 f32 更加精确。在需要高精度计算的情况下，也更推荐使用 f64。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2.0; // f64 类型
let y: f32 = 3.14; // 指定为 f32 类型
let a = 1.0f32; // 指定为 f32 类型
<span class="boring">}</span></code></pre></pre>
<h3 id="布尔类型"><a class="header" href="#布尔类型">布尔类型</a></h3>
<p>布尔类型 <code>true</code> 或 <code>false</code> 常用于条件判断和逻辑操作，是控制流中不可或缺的组成部分。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let yes: bool = true;
let no: bool = false;
let not = !no;
let and = yes &amp;&amp; no;
let or = yes || no;
let xor = yes ^ no;
<span class="boring">}</span></code></pre></pre>
<h3 id="字符类型"><a class="header" href="#字符类型">字符类型</a></h3>
<p>Rust 的字符类型长度为 4 字节，不仅可以表示 ASCII 字符，还可以表示所有的 Unicode 字符。这意味着你可以使用任何语言的字符，甚至表情符号。这在处理多语言文本时非常有用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let heart_eyed_cat = '😻';
let letter = 'ℤ';
<span class="boring">}</span></code></pre></pre>
<h3 id="字符串类型"><a class="header" href="#字符串类型">字符串类型</a></h3>
<p>Rust 的 String 类型是 UTF-8 编码，且是堆分配的。
String 并不是以空字符结尾的，不像 C/C++ 中的字符串。
Rust 中有多种字符串类型，例如 CString、PathBuf、OsString 等。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from("Hello, 🌍!");
<span class="boring">}</span></code></pre></pre>
<h2 id="复合类型"><a class="header" href="#复合类型">复合类型</a></h2>
<p>复合类型可以将多个值组合在一起</p>
<h3 id="元组"><a class="header" href="#元组">元组</a></h3>
<p>元组可以包含不同类型的多个值，其长度是固定的，非常适合需要将不同类型的值组合在一起的场景。例如，函数可以通过返回元组来传递多个不同类型的值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup: (i32, f64, char) = (500, 6.4, 'a');
let (x, y, z) = tup; // 解构元组
println!("The value of y is: {}", y);
println!("The second value is: {}", tup.1); // 通过索引访问元组
<span class="boring">}</span></code></pre></pre>
<h3 id="数组"><a class="header" href="#数组">数组</a></h3>
<p>数组的所有元素必须是相同类型，长度在编译时确定。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr: [i32; 3] = [1, 2, 3];
println!("The first element is: {}", arr[0]);
<span class="boring">}</span></code></pre></pre>
<p>数组在栈上分配，适合存储固定大小的集合。如果需要动态大小的集合，可以使用 Vec（向量）它类似于数组但具有可变长度。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vec = Vec::new();
vec.push(1);
vec.push(2);
println!("The vector contains: {:?}", vec);
<span class="boring">}</span></code></pre></pre>
<h2 id="控制流"><a class="header" href="#控制流">控制流</a></h2>
<p>控制流用于控制代码的执行顺序，包括条件判断和循环。</p>
<h3 id="条件判断"><a class="header" href="#条件判断">条件判断</a></h3>
<p>Rust 使用 <code>if</code>、<code>else if</code> 和 <code>else</code> 关键字来进行条件判断：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;
    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}</code></pre></pre>
<p>条件判断表达式必须返回布尔类型，类似于其他编程语言。一个独特之处是，if 可以作为表达式使用，从而简化代码。例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let condition = true;
let number = if condition { 5 } else { 6 }; // 根据条件赋值
println!("The value of number is: {}", number);
<span class="boring">}</span></code></pre></pre>
<p>这使得代码更加简洁，并且可以减少变量的重复声明。</p>
<h3 id="循环"><a class="header" href="#循环">循环</a></h3>
<p>Rust 提供了三种循环方式：loop、while 和 for。</p>
<p><strong>loop：</strong> 无限循环，通常用于那些需要一直运行，直到某个条件触发的场景，例如服务器的请求处理循环。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut count = 0;
loop {
    println!("count = {}", count);
    count += 1;
    if count == 5 {
        break;
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>while：</strong> 在条件为 <code>true</code> 时重复执行代码，适合在不确定循环次数，但知道结束条件的情况下使用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut number = 3;
while number != 0 {
    println!("{}!", number);
    number -= 1;
}
println!("LIFTOFF!!!");
<span class="boring">}</span></code></pre></pre>
<p><strong>for：</strong> 遍历集合中的每一个元素，通常用于遍历数组，它简洁且安全，不容易发生越界错误。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [10, 20, 30, 40, 50];
for element in a.iter() {
    println!("the value is: {}", element);
}
for number in 1..4 { // `1..4` 表示从 1 到 3
    println!("{}", number);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="函数"><a class="header" href="#函数">函数</a></h2>
<p>在 Rust 中，函数是基本的代码结构单元。函数的声明使用 <code>fn</code> 关键字，并且必须明确标注参数类型和返回值类型。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let result = add(5, 3);
    println!("The result is: {}", result);
}

fn add(a: i32, b: i32) -&gt; i32 {
    a + b // Rust 中可以省略 return 关键字，只需将返回值作为最后一个表达式
}</code></pre></pre>
<p>函数返回值的类型在箭头 -&gt; 之后指定。如果函数不返回值，返回类型可以省略或标为 ()。</p>
<p>函数是组织代码、减少重复、提高可读性的重要工具。在函数内，最后一个表达式的值会被隐式返回，也可以显式使用 return 关键字来返回某个值。</p>
<h2 id="作用域于所有权"><a class="header" href="#作用域于所有权">作用域于所有权</a></h2>
<p>Rust 中有一个非常重要的概念叫“所有权 (Ownership)”。所有权规则确保内存安全，无需<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">垃圾回收</a>机制。</p>
<h3 id="所有权规则"><a class="header" href="#所有权规则">所有权规则</a></h3>
<ol>
<li>每个值在 Rust 中都有一个所有者 (Owner)。</li>
<li>同一时间内，值只能有一个所有者。</li>
<li>当所有者离开作用域，值将被丢弃，内存被释放。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from("hello");  // s 进入作用域
    takes_ownership(s);  // s 的所有权转移到函数内，之后无法再使用 s

    let x = 5;  // x 进入作用域
    makes_copy(x);  // x 是基本类型，复制后仍然可以使用
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
} // some_string 离开作用域并调用 `drop`，内存被释放

fn makes_copy(some_integer: i32) {
    println!("{}", some_integer);
} // some_integer 是基本类型，离开作用域不会有特殊操作</code></pre></pre>
<p>所有权机制的独特之处在于，它避免了数据竞争和悬垂指针问题，确保了内存安全。在 <code>String</code> 这样的复杂数据类型中，所有权的转移意味着你可以避免多次释放内存的情况。此外，Rust 还提供了“借用 (Borrowing)”的概念来克服所有权的局限性。</p>
<h3 id="借用与引用"><a class="header" href="#借用与引用">借用与引用</a></h3>
<p>引用允许你在不获取所有权的情况下访问数据。引用使用 <code>&amp;</code> 符号表示，而可变引用使用 <code>&amp;mut</code> 表示：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&amp;s1); // 借用 s1
    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len() // 使用引用，不获得所有权
}</code></pre></pre>
<p>通过使用引用，你可以避免所有权的转移，从而继续在主函数中使用变量。Rust 编译器会确保引用的安全性，防止<a href="https://oi-wiki.org/lang/reference/">悬垂引用</a>。</p>
<p>可变引用允许你修改借用的变量，但在同一时间内，特定数据只能有一个可变引用或多个不可变引用，以确保数据一致性：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from("hello");
    change(&amp;mut s);
    println!("{}", s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}</code></pre></pre>
<p>这种严格的规则使得 Rust 在没有垃圾回收器的情况下依然能实现内存安全。</p>
<h1 id="exercise"><a class="header" href="#exercise">Exercise</a></h1>
<p>在编辑器中打开 <code>exercises/1-foundations-of-rust/1-basic-syntax/1-basic-syntax</code>。此文件夹中包含许多练习，可以用于练习基本的 Rust 语法。</p>
<p>要开始练习，请运行以下命令：</p>
<pre><code class="language-bash">cargo run --bin 01
</code></pre>
<p>这将尝试编译并运行 exercies 1。</p>
<p>要继续其他练习，只需更改练习编号。</p>
<p>其中一些练习包含单元测试，需要测试 <code>src/bin/01.rs</code> 请运行：</p>
<pre><code class="language-bash">cargo test --bin 01
</code></pre>
<p>确保所有测试都通过！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../foundations/first-project.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../foundations/ownership-and-references.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../foundations/first-project.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../foundations/ownership-and-references.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../theme/pagetoc.js"></script>


    </body>
</html>